GraphQL is a new API standard that was invented by Facebook.

Enables declarative data fetching

GraphQL server exposes a single endpoint and responds to queries.

Replacement-ish for REST, which struggles with three big factors:
1) Increased mobile usage creates need for efficient data loading.
    graphql minimizes amount of data needed to tranfer
2) Variety of different frontend frameworks and platforms on the client-side
3) Fast dev speed and expectation for rapid feature development.
    REST's exposure paradigm can slow things down.


FB uses GraphQL since 2012 in their native mobile apps.
First time presented publicly at React.js Conf 2015
Can be used with any programming language and framework- predominantly limited to react in public mind but not true.

Netflix and Coursera were working on similar ideas, Netflix open-sourced their solution Falcor. Coursera cancelled their own version after GraphQL was open sourced. It's used pretty widely now. There are entire conferences devoted to it. Lots of resources.

Over the last decade, REST has become the (fuzzy) standard for designing web APIS.

GRAPHQL VS REST
-Great ideas in REST: stateless servers & structured access to resources.
-REST is a strict specification, but the concept was wildly interpreted.
-Rapidly changing requirements on client-side don't go well with the static nature of REST.

GraphQL was developed to cope with the need for more flexibility and efficiency in client-server communications.

EXAMPLE: BLogging app with REST
needs separate endpoint for /users/<id>, /users/<id>/<posts>, /users/id/followers. That means three queries, and fetching user data on a name for example means fetching the whole document for their data. 

You could design the API around only exposing the exact data you're using, but that means every time you update the front, you need to redo the back. Modern design is about rapid iteration- that's going to demand constant change and you don't want to live in that world.

COUNTEREXAMPLE: Blogging app with GraphQL
Single API endpoint. The one request you send is a POST (vs the GET) with a query that specifies all the data you want, and only the data you want. Server side it packages all of these stuff into one JSON object and returns that as a POST. 

Other high-level differences:
No more under/overfetching, as the example illustrates. Overfetching is getting more data than you need and wasting data, underfetching means you're not getting enough data and have to send a ton of requests.
The ideal design pattern for REST is roughly  structure endpoints according to clients data needs but again, this fucks with rapid product iterations. GraphQL doesn't need API adjustment when product requirements/frontend design change.
Because you know exactly what's being requested (vs the whole doc) you know what data is being read and requested by clients, and lets you do fine-grained observation which helps with performance optimization.
GraphQL uses strong type system to define the capabilities of an API.
GraphQL's Schema serves as a contract between client and server
    This means frontend and backend can work completely independent from each other!


SCHEMA DEFINITION LANGUAGE (SDL)
  Defining simple types:

type Person {
    name: String!  # the ! means required
    age: Int!
    posts: [Post!]! # [] == list
}

type Post {
    title: String!
    author: Person! # adds relation to Person
}

this defines a one to many relation between person and post

Example Query:

{
  allPersons  {  # root field of the query
    name  # this is the only field in the payload, so only name is returned
  }
}

if you added age under name, it'd return people's ages
you could add arguments -> allPersons(last: 2) to get only the last two people
you could do
{
    allPersons  {
        name
            posts  {
                title
            }
    }
}
resolving that will get every person's name, and the title of all their posts
--------
CRUD except for R is handled with Mutations:
3 Kinds of mutations
-Creating new data
-Updating existing data
-Deleting existing data

example mutation:

mutation  {
  createPerson(name: "Bob", age: 36)  {
    name
    age
  }
}
will return the name/age of the result (which is redundant here but not always)

One pattern you often find is GraphQL types have unique ids generated by the server

example extended Person type:
type Person {
  id: ID!
  name: String!
  age: Int!
}

this lets you write
mutation {
  createPerson(name: "Bob", age: 36) {
    id
  }
}
This lets you query the id of Bob, which is data you previously wouldn't have avavailable.

REALTIME UPDATES WITH SUBSCRIPTIONS

Subscriptions let you subscribe to an event which opens a continuous connection to the server. Whenever the event happens, the server responds with the payload.
Example:
subscription {  # keyword describing what's happening
  newPerson {  
    name
    age
  }
}

Unlike mutations and queries, subscriptions are a stream of data (vs request/ response) sent to the client.
So for EACH event, the server pushes the corresponding data to the subhscribed client.
--------
The GraphQL SCHEMA
-defines capabilities of the API by specifying how a client can fetch and update data
-represents CONTRACT between client and server
-is a collection of GraphQL types with special ROOT TYPES

Root Types

type Query {
  ...
}

type Mutation {
  ...
}

type Subscription {
  ...
}
These are the root types for GraphQL. To define them in the schema so you could do the stuff in the previous requests you'd do:
FULL EXAMPLE SCHEMA
type Query {
      allPersons(last: Int): [Person!]!
      allPosts(last: Int): [Post!]!
}

type Mutation {
    createPerson(name: String!, age: String!): Person!
    updatePerson(id: ID!, name: String!, age: String!): Person!
    deletePerson(id: ID!) Person!
    createPost(title: String!): Post!
    updatePost(id: ID!, title: String!): Post!
    deletePost(id: ID!): Post!
}

type Subscription {
  newPerson: Person!
  updatedPerson: Person!
  deletedPerson: Person!
  newPost: Post!
  updatedPost: Post!
  deletedPost: Post!
}

type Person {
  id: ID!
  name: String!
  age: Int!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  author: Person!
}

As-is this doesn't really let you change the relationship between persons and posts, you'd want to add posts: [Post!]! in updatePerson and vice versa.


------------
BIG PICTURE (ARCHITECTURE)
GraphQL is only a _specification_
If you want to use graphQL, you need to build it yourself (in theory) in any language you like. There's sample
implementations, and there's also services like GraphTool that let you build a GraphQL server out of the box.

Three common architectural use cases:
1. GraphQL server with a connected database
2. GraphQL server to integrate existing system
3. A hybrid approach with a connected database and integration of existing 3rd party/legacy systems already existing.

Use Case 1: GraphQL server with a connected database
-used for greenfield projects  # greenfield == new fresh ground, no existing environment, no constraints from prior work
-uses single web server that implements GraphQL
-server resolves queries and constructs response with data that it fetches from the database

GraphQL is transport-layer agnostic, it doesn't care if you're using TCP, websockets, or carrier pigeon.
It's agnostic about database, it works on SQL like AWS Aurora or NoSQL like MongoDB

Use Case 2: GraphQL server integrating existing systems
-compelling use case for companies with legacy infrastructures and many different APIs
-GraphQL can be used to unify existing systems and hide complexity of data fetching logic
-the server doesn't care about what the data sources are (databases, web services, 3rd party APIs)

Use Case 3: Hybrid approach with connected database & integrated systems
Basically combination of 1 and 2

----
RESOLVER FUNCTIONS
-GraphQL queries/mutations consist of set of fields
-GraphQL server has one resolver function per field
-The purpose of each resolver is to retrieve the data for its corresponding field

----
GRAPHQL Clients
-GraphQL is great for frontend developers as data fetching complexity can be pushed to the server-side
-client dgaf where data is coming from
-opportunity for new abstractions on the frontend

--
From imperative to declarative data fetching:
  Imperative data fetching, a cliient will:
    1. construct and sent HTTP request (eg with fetch in Javascript)
    2. receive and parse server response
    3. store data locally
    4. display data in the UI
  Declarative data fetching, a client will:
    1. Describe data requirements
    2. Display information in the UI
everyhing in between those two steps is handled by the server. GraphQL type libraries like Relay and Apollo provide the abstraction you need to be able to focus on the moving parts of your application rather than infrastructure/data fetching logic.

------------

CLIENTS

Two big GraphQL clients right now: Apollo Client, a community-driven effort to build a client for all major dev platforms. The second is Relay and is Facebook's homegrown GraphQL client that heavily optimizes for performance and is only available on the web.

------------
SERVER

GraphQL is generally considered primarily for the benefit of the frontend, but the server-side benefits a ton too because it lets you focus on describing the data vs optimizing/implementing/futzing with endpoints.

The fundamental execution algorithm for GraphQL works roughly like this:
The query is traversed field by field, and on each field it executes a "resolver" function. So example:
    EXAMPLE SCHEMA
type Query {
  author(id: ID!): Author
}

type Author {
  posts: [Post]
}

type Post {
  title: String
  content: String
}
     EXAMPLE QUERY
query {
  author(id: "abc") {
    posts {
      title
      content
    }
  }
}

So first it would check that every field in the query can get a type.
    EXAMPLE CHECKED
query: Query {
  author(id: "abc"): Author {
    posts: [Post] {
      title: String
      content: String
    }
  }
}
So then it just runs resolvers at every field, breadth-first, so: Query.author, which brings a result that gets fed to its child, the Author.posts resolver, which then goes down the list of children hitting up the Post.title resolver and Post.content resolver.

And then in the end, the execution algorithm puts things back into the right shape and returns that.

Most GraphQL server implementations will provide default resolvers, so you don't have to specify a function for every single field. If you want to look more in depth into execution, https://dev-blog.apollodata.com/graphql-explained-5844742f195e

That strategy is somewhat naive, though, so you generally want to batch resolving. You can do that by wrapping the fetching function in a utility that waits for all the resolvers to run, sees what they're trying to fetch, and then makes sure to only hit each once.

Then if your API supports batched requests, you can take it one step further and only do one single combined fetch, for massive value. In JavaScript, you can use DataLoader, and there's similar untilities for other languages.
------------
MORE GRAPHQL CONCEPTS:

Enhancing Reusability with Fragments
A fragment is a collection of fields on a specific type. So if you had like:
type User {
  name: String!
  age: Int!
  email: String!
  street: String!
  zipcode: String!
  city: String!
}
You could make a fragment as subset of those fields for only the stuff you want, like:

fragment addressDetails on User {
  name
  street
  zipcode
  city
}

And this bundles them so you can just write
{
  allUsers {
    ... addressDetails
  }
}
instead of spelling out all the other stuff.

Parameterizing Fields with Arguments
When you're defining a GraphQL type, each field can take 0 or more arguments. Like function arguments in typed programming languages, each argument needs a name and a type. In GraphQL (like Python) you can have default values for args.

Example, when defining Query you could do:
type Query {
  allUsers(olderThan: Int = -1): [User!]!  # this lets you get all users older than Int, defaulting to -1
}

-Named Query Results with Aliases-
GraphQL has the big upside of letting you do multiple queries in a single request. Buuuut since the response data is shaped after the structure of the fields being represented, if you're asking for the same thing a bunch things can get awkward. (like querying for the name field over a bunch of diff users)
The way to get around this is to use aliases, which is specifying names for the query results.
Example of Aliases: 
{
  first: User(id: "1") {
    name
  }
  second: User(id: "2") {
    name
  }
}
So the server is going to have a name to assign to each of those userids, which means it's not going to think of them as the same field for different arguments.

-Advanced SDL-

Object & Scalar Types
-Scalar types are concrete units of data. There are 5 predefined ones: String, Int, Float, Boolean, ID
-Object types have fields that express the properties of that type and are composable. Ex: User or Post
In every GraphQL schema, you can define your own scalar and object types. 'Date' is a pretty common custom example.

Enums
GraphQL lets you define enumerations (short: enums), which lets you express the semantics of a type that has a fixed limited set of values. We could thus define a type called Weekday to represent all the days of a week:

enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}
Note that technically enums are special kinds of scalar types.

Interface
An interface lets you describe a type in an abstract way. It lets you set fields that any concrete type
implementing the interface needs to have. For example, most schemas require every type to have an id field.
To be sure you don't fuck up, you can make an interface with the id field and then make sure every custom type implements it.

Union Types
Union types let you say a type should be EITHER of a collection of other types. So if you had an Adult type, and a Child type, you could define a union Person = Adult | Child. This also lets you query for conditional fragments:
{
  allPersons {
    name # works for `Adult` and `Child`
    ... on Child {
      school
    }
    ... on Adult {
       work
    }
  }
}
------------
TOOLING AND ECOSYSTEM