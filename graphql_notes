GraphQL is a new API standard that was invented by Facebook.

Enables declarative data fetching

GraphQL server exposes a single endpoint and responds to queries.

Replacement-ish for REST, which struggles with three big factors:
1) Increased mobile usage creates need for efficient data loading.
    graphql minimizes amount of data needed to tranfer
2) Variety of different frontend frameworks and platforms on the client-side
3) Fast dev speed and expectation for rapid feature development.
    REST's exposure paradigm can slow things down.


FB uses GraphQL since 2012 in their native mobile apps.
First time presented publicly at React.js Conf 2015
Can be used with any programming language and framework- predominantly limited to react in public mind but not true.

Netflix and Coursera were working on similar ideas, Netflix open-sourced their solution Falcor. Coursera cancelled their own version after GraphQL was open sourced. It's used pretty widely now. There are entire conferences devoted to it. Lots of resources.

Over the last decade, REST has become the (fuzzy) standard for designing web APIS.

GRAPHQL VS REST
-Great ideas in REST: stateless servers & structured access to resources.
-REST is a strict specification, but the concept was wildly interpreted.
-Rapidly changing requirements on client-side don't go well with the static nature of REST.

GraphQL was developed to cope with the need for more flexibility and efficiency in client-server communications.

EXAMPLE: BLogging app with REST
needs separate endpoint for /users/<id>, /users/<id>/<posts>, /users/id/followers. That means three queries, and fetching user data on a name for example means fetching the whole document for their data. 

You could design the API around only exposing the exact data you're using, but that means every time you update the front, you need to redo the back. Modern design is about rapid iteration- that's going to demand constant change and you don't want to live in that world.

COUNTEREXAMPLE: Blogging app with GraphQL
Single API endpoint. The one request you send is a POST (vs the GET) with a query that specifies all the data you want, and only the data you want. Server side it packages all of these stuff into one JSON object and returns that as a POST. 

Other high-level differences:
No more under/overfetching, as the example illustrates. Overfetching is getting more data than you need and wasting data, underfetching means you're not getting enough data and have to send a ton of requests.
The ideal design pattern for REST is roughly  structure endpoints according to clients data needs but again, this fucks with rapid product iterations. GraphQL doesn't need API adjustment when product requirements/frontend design change.
Because you know exactly what's being requested (vs the whole doc) you know what data is being read and requested by clients, and lets you do fine-grained observation which helps with performance optimization.
GraphQL uses strong type system to define the capabilities of an API.
GraphQL's Schema serves as a contract between client and server
    This means frontend and backend can work completely independent from each other!


SCHEMA DEFINITION LANGUAGE (SDL)
  Defining simple types:

type Person {
    name: String!  # the ! means required
    age: Int!
    posts: [Post!]! # [] == list
}

type Post {
    title: String!
    author: Person! # adds relation to Person
}

this defines a one to many relation between person and post

Example Query:

{
  allPersons  {  # root field of the query
    name  # this is the only field in the payload, so only name is returned
  }
}

if you added age under name, it'd return people's ages
you could add arguments -> allPersons(last: 2) to get only the last two people
you could do
{
    allPersons  {
        name
            posts  {
                title
            }
    }
}
resolving that will get every person's name, and the title of all their posts
--------
CRUD except for R is handled with Mutations:
3 Kinds of mutations
-Creating new data
-Updating existing data
-Deleting existing data

example mutation:

mutation  {
  createPerson(name: "Bob", age: 36)  {
    name
    age
  }
}
will return the name/age of the result (which is redundant here but not always)

One pattern you often find is GraphQL types have unique ids generated by the server

example extended Person type:
type Person {
  id: ID!
  name: String!
  age: Int!
}

this lets you write
mutation {
  createPerson(name: "Bob", age: 36) {
    id
  }
}
This lets you query the id of Bob, which is data you previously wouldn't have avavailable.

REALTIME UPDATES WITH SUBSCRIPTIONS

Subscriptions let you subscribe to an event which opens a continuous connection to the server. Whenever the event happens, the server responds with the payload.
Example:
subscription {  # keyword describing what's happening
  newPerson {  
    name
    age
  }
}

Unlike mutations and queries, subscriptions are a stream of data (vs request/ response) sent to the client.
So for EACH event, the server pushes the corresponding data to the subhscribed client.
--------
The GraphQL SCHEMA
-defines capabilities of the API by specifying how a client can fetch and update data
-represents CONTRACT between client and server
-is a collection of GraphQL types with special ROOT TYPES

Root Types

type Query {
  ...
}

type Mutation {
  ...
}

type Subscription {
  ...
}
These are the root types for GraphQL. To define them in the schema so you could do the stuff in the previous requests you'd do:
FULL EXAMPLE SCHEMA
type Query {
      allPersons(last: Int): [Person!]!
      allPosts(last: Int): [Post!]!
}

type Mutation {
    createPerson(name: String!, age: String!): Person!
    updatePerson(id: ID!, name: String!, age: String!): Person!
    deletePerson(id: ID!) Person!
    createPost(title: String!): Post!
    updatePost(id: ID!, title: String!): Post!
    deletePost(id: ID!): Post!
}

type Subscription {
  newPerson: Person!
  updatedPerson: Person!
  deletedPerson: Person!
  newPost: Post!
  updatedPost: Post!
  deletedPost: Post!
}

type Person {
  id: ID!
  name: String!
  age: Int!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  author: Person!
}

As-is this doesn't really let you change the relationship between persons and posts, you'd want to add posts: [Post!]! in updatePerson and vice versa.


------------
BIG PICTURE (ARCHITECTURE)
GraphQL is only a _specification_
If you want to use graphQL, you need to build it yourself (in theory) in any language you like. There's sample
implementations, and there's also services like GraphTool that let you build a GraphQL server out of the box.

Three common architectural use cases:
1. GraphQL server with a connected database
2. GraphQL server to integrate existing system
3. A hybrid approach with a connected database and integration of existing 3rd party/legacy systems already existing.

Use Case 1: GraphQL server with a connected database
-used for greenfield projects  # greenfield == new fresh ground, no existing environment, no constraints from prior work
-uses single web server that implements GraphQL
-server resolves queries and constructs response with data that it fetches from the database

GraphQL is transport-layer agnostic, it doesn't care if you're using TCP, websockets, or carrier pigeon.
It's agnostic about database, it works on SQL like AWS Aurora or NoSQL like MongoDB

Use Case 2: GraphQL server integrating existing systems
-compelling use case for companies with legacy infrastructures and many different APIs
-GraphQL can be used to unify existing systems and hide complexity of data fetching logic
-the server doesn't care about what the data sources are (databases, web services, 3rd party APIs)

Use Case 3: Hybrid approach with connected database & integrated systems
Basically combination of 1 and 2

----
RESOLVER FUNCTIONS
-GraphQL queries/mutations consist of set of fields
-GraphQL server has one resolver function per field
-The purpose of each resolver is to retrieve the data for its corresponding field

----
GRAPHQL Clients
-GraphQL is great for frontend developers as data fetching complexity can be pushed to the server-side
-client dgaf where data is coming from
-opportunity for new abstractions on the frontend

--
From imperative to declarative data fetching:
  Imperative data fetching, a cliient will:
    1. construct and sent HTTP request (eg with fetch in Javascript)
    2. receive and parse server response
    3. store data locally
    4. display data in the UI
  Declarative data fetching, a client will:
    1. Describe data requirements
    2. Display information in the UI
everyhing in between those two steps is handled by the server. GraphQL type libraries like Relay and Apollo provide the abstraction you need to be able to focus on the moving parts of your application rather than infrastructure/data fetching logic.

------------

CLIENTS

Two big GraphQL clients right now: Apollo Client, a community-driven effort to build a client for all major dev platforms. The second is Relay and is Facebook's homegrown GraphQL client that heavily optimizes for performance and is only available on the web.

------------
SERVER
