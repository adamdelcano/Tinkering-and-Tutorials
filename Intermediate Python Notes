Intermediate Python Notes
----------------------
List can contain multiple data types, duplicate elements.
list.insert(index, value) lets you insert items into list at index
list.remove(value) lets you kill them (valueerror if not in list)
list.clear() empties list
sorted(list) returns a sorted copy of list
mylist = [0] * 5 will make [0,0,0,0,0]
slice syntax: [start index : stop index : step]
mylist = [1,2,3,4,5,6,7,8,9,10]
mylist[1:5] = [2,3,4,5]

copy_mylist = mylist
copy_mylist.append(11)
mylist will now have 11 at the end
because both list variabless refer to the same list in the memory
copy_mylist = mylist.copy() or list(mylist) or mylist[:] all make copies that you can modify
-----------------------
tuples: immutable data type, is created by parentheses with common
mytuple = ("Max", 28, "Boston")
technically parentheses optional
mytuple = "Max", 28, "Boston" is valid
mytuple = "Max" is a string
so is mytuple = ("Max")
but mytuple = "Max", is valid
tuple(item) makes a tuple out of iterator
access them with index (mytuple[1] will get 28)
tuple.count(value) counts the number of value in tuple
tuple.index(value) returns the first index of value in tuple, will return ValueError if not in tuple
list(tuple) makes list, tuple(list) makes tuple

my_tuple = (0, 1, 2, 3, 4)
i1, *i2, i3 = my_tuple
i1 == 0
i2 == 1,2,3
i3 == 4
---------------
dicts: unordered, mutable, key:value
to merge two dicts,
my_dict = {"name",:"Max", "age":28, "email":"max@xyz.com"}
my_dict_2 = dict(name="Mary", age=27, city = "Boston")
my_dict.update(my_dict_2)

my_dict == {'name': 'Mary', 'age': 27, 'email': 'max@xyz.com', 'city': 'Boston'}

can't make mutable things keys
-------------
set: unordered, mutable, no dupes
myset = {1,2,3,1,2}
myset == {1,2,3}
myset = set("Hello")
myset == {'o', 'l', 'e', 'H'}
myset = {}
type(myset) == dict
myset = set()
type(myset) == set
myset.add(value) adds value to set
myset.discard(value) takes it out and ignores if not found
myset.pop() returns an arbitrary element while popping it out
you can iterate over it with a for loop 

unions and intersection of sets
odds = {1,3,5,7,9}
evens = {0,2,4,6,8}
primes = {2,3,5,7}

u = odds.union(evens) 
u == {0,1,2,3,4,5,6,7,8,9}
i = odds.intersection(evens)
i == set()
op = odds.intersection(primes)
op == {3,5,7}
ip = primes.intersection(evens)
ip == {2}

diff = primes.difference(odds)
diff == {2}
diff = odds.difference(primes)
diff == {1,9}
sym_diff = odds.symmetric_difference(primes)
sym_diff == {1,2}
sym_diff = primes.symmetric_difference(odds)
sym_dif == {1,2}

odds.update(primes)
odds == {1,2,3,5,7,9}
odds.intersection_update(evens)  # keeps only the stuff in both sets
odds == {2]}

odds = {1,3,5,7,9}
odds.difference_update(primes)  # removes elements from the other set
odds == {1}
also a symmetric difference version

set,issubset(other_set)  # returns True if all of set is in other_set
set.issuperset(other_set)  # returns True if all of other_set is in set
set.isdisjoint(other_set)  # returns True if there are no interesections, that is they have no elements in common


remember that simple assignment means the set has another name, it doesn't make a copy!
other_set = set.copy()
or
other_set = set(set)

Frozenset is immutable version of set
a = frozenset([1,2,3,4])
can't update

--------------

Strings
ordered and immutable collection data type
my_string = 'Hello World'
my_string.startswith('H') == True
my_string.startswith('Hello') == True
my_string.startswith('W') == False
my_string.find('l') == 2
my_string.count('o') == 2, my_string.count('p') == 0
new_string = my_string.replace('World', 'Universe')
my_string == 'Hello World'
new_string == 'Hello Universe'
var = 3.12345
my_string = "the variable is {}".format(variable)
my_string == "the variable is 3.12345"

---------------

The Collections modules implements special container data types: 
# Counter, namedtuple, OrderedDict, defaultdict, deque
-
from collections import Counter
A container that stores the elements as dictionary keys and their counts as dictionary values.
a = "aaaabbbccc"
my_counter = Counter(a)
my_counter == Counter({'a':4, 'b':3, 'c':3})
Has methods like .most_common() <- list with tuples of most common elements and count
-
from collections import namedtuple
Easy to create and lightweight object type similar to a struct
Point = namedtuple('Point', 'x,y') # creates a Point class with the values x and y
pt = Point(1, -4) # creates a Point at 1,-4
-
from collections import OrderedDict
it's a dict that cares about order, but less important since python 3.7
ordered_dict = OrderedDict()
ordered_dict['a'] = 1
ordered_dict['b'] = 2
ordered_dict['c'] = 3
ordered_dict == {'a':1, 'b':2, 'c':3}
-
from collections import defaultdict
it's a dict that comes with a default type value for all keys with un-set values
d = defaultdict(int)
d['a'] = 1
d['b'] = 2
d == {'a':1, 'b':2}
what is d['c']? d['c'] == 0

This avoids KeyErrors from absent keys
-
from collections import deque
The deque is a Double Ended Que- it can have elements removed from both ends very efficiently
d = deque()
d.append(1) # appends
d.append(2)
d == deque([1,2])
d.appendleft(3) # appends to the left
d == deque([3,1,2])
d.pop() # pops
d == deque([3,1])
d.popleft() # pops from left
d == deque([1])
d.clear()  # wipes everything 
d == deque([])
d.extend([4,5,6]) # adds a bunch
d == deque([4,5,6])
d.extendleft([1,2,3]) # from the left
d == deque([1,2,3,4,5,6])
d.rotate(1) # moves everything over one
d == deque([6,1,2,3,4,5])
d.rotate(2) # or two
d == deque([4,5,6,1,2,3])
d.rotate(-3) # can be - for backwards
d == deque([1,2,3,4,5,6])
-------------------------
ITERTOOLS
itertools: product, permutations, combinations, accumulate, groupby, and infinite iterators
iterators are data tools that can be used by a for loop, simplest example is a list.
-
Product
from itertools import product
a = [1,2]
b = [3,4]
prod = product(a,b) # computes cartesian product of them
prod == <itertools.product object>  # all of these are iterators
list(prod) == [(1,3), (1,4), (2,3), (2,4)]  # list shows what it looks like
prod = product(a,b, repeat=2) # repeats
list(prod) == [(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4), (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4), (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4), (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]
a = [1,2]
b = [3]
prod = product(a,b, repeat=2) # smaller version so you can see what happens
list(prod) == [(1, 3, 1, 3), (1, 3, 2, 3), (2, 3, 1, 3), (2, 3, 2, 3)]
it repeats the process
-
Permutations
Gives every permutation of the things fed to it.
from itertools import permutations
a = [1,2,3]
perm = permutations(a)
list(perm) == [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1
perm = permutations(a, 2) # allows you to make length 2 for example permutations only
list(perm) = [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
-
Combinations 
Makes all possible combinations with specified length
from itertools import combinations

a = [1,2,3,4]
comb = combinations(a, 2) # length is mandatory
list(comb) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]

from itertools import combinations_with_replacement # lets replacement happen so items can hit themselves
comb_wr = combinations_with_replacement(a,2)
list(comb_wr) == [(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)]  
-
Accumulate
Allows accumulating sums 
from itertools import accumulate
a = [1,2,3,4]
>>> a
[1, 2, 3, 4]
>>> acc = accumulate(a)
>>> print(a)
[1, 2, 3, 4]
>>> print(acc)
<itertools.accumulate object at 0x10d1817c8>  # still an iterator!
>>> print(list(acc))
[1, 3, 6, 10]        # adds the thing before each item, so: nothing in, add 1 = 1. Running total is 1, add 2 = 3, running total is 3, add 3 = 6, running total is 6, add 4=10

Can also be made to do non-additions with science!
import operator
from itertools import accumulate
a = [1,2,3,4]
acc = accumulate(a, func=operator.mul)
list(acc) == [1,2,6,24] # 1 stays, 1*2 = 2, 2*3 = 6, 6 * 4 = 24
acc = accumulate(a, func=max) # checks max
list(acc) == [1,2,3,4] # 1 > null, 2>1, 3>2, 4>3
a = [1,2,5,3,4]
acc = accumulate(a, func=max)
list(acc) == [1,2,5,5,5] # 1 > null, 2>1, 5>2, 5>3, 5>4
-

Group
Lets you map things by a function
from itertools import groupby

def smaller_than_3(i):
    return x < 3

a = [1,2,3,4]
group_obj = groupby(a, key=smaller_than_3)
print(group_obj)
<itertools.groupby object at ...>

for key, value in group_obj:
    print(key, list(value))

True [1,2]
False [3,4]

It can also take lambda functions!  

-

infinite iterators:
from itertools import count, cycle, repeat
for i in count(10):
    print(i)
# starts at 10 and goes forever

a = [1,2,3]
for i in cycle(a):
    print(i)
# prints 1,2,3 infinitely

for i in repeat(1): # can take a second arg that limits
    print(i)
# print 1 infinitely


------------

Lambdas
One line anonymous (defined without a name) function in the form:

lambda arguments: expression
# creates a function with some arguments and returns the expression

add10 = lambda x: x+10
add10(5) == 15

only real difference between this and
def add10_func(x):
    return x + 10
is that the lambda is shorter and only in one line

They can have multiple arguments
mult = lambda x,y: x*y
mult(2,3) == 6

Lambdas are very useful for keys in other functions, eg:
sorted(thing, key = lambda x: x[1]) to sort by the second element in each part of thing

points2D = [(1,2), (15,1), (5, -1), (10,4)]
points2D_sorted = sorted(points2D)  #sorts by the first element
points2D_sorted = sorted(points2D, key=lambda x:x[1]) # sorts by second element

map(func, sequence) # this is super relevant for lambdas!

a = [1,2,3,4,5]
b = map(lambda x:x*2, a)
# note though
print(b) == <map object etc etc>
list(b) == [2,4,6,8,10]

This map mostly not super useful b/c list comprehension but can happen.

filter(func, sequence) # returns all elements that the function returns true for

b = filter(lambda x: x%2 == 0, a)
list(b) == [2,4,6]

Can again be replicated by list comp: b = [x for x in a if x%2 == 0]
reduce(func, sequence)
from functools import reduce
Applies the function to the elements and returns a single value
a = [1,2,3,4,5,6]
product_a = reduce(lambda x,y: x*y, a)
product_a == 720   # 1, 1*2 = 2, 2*3 = 6, 6 * 4 = 24, 24 * 5 = 120, 120 * 6 = 720
-----------------------------

Exceptions and Errors

A python program terminates once it hits an error. An error can be a syntax error or an exception.

Syntax Error occurs when the parser detects a syntactically incorrect statement. 
Ex: 
a = 5 print(a)
or
print(a))

Exception error happens when syntactically correct stuff still doesn't work.

a = 5 + '10'
TypeError: unsupported operand type(s) for +: 'int' and 'str'

import somemodule
ModuleNotFoundError: No module named somemodule

a = 5
b = c
NameError: 'c' is not defined

f = open('somefile.txt')
FileNotFoundError: [Errno 2] No such file or directory: 'somefile.txt'

a = [1,2,3]
a.remove(1)
print(a)
[2,3]
a.remove(4)
ValueError: list.remove(x): x not in list

a = [1,2,3]
a[3]
IndexError: list index out of range

my_dict = {'name': 'Max'}
my_dict['age']
KeyError: 'age'

-
Raising exceptions

x = -5
if x < 0:
    raise Exception('x should be positive')

will raise Exception, but not if x is >= 0

assert (x>=0), 'x is not positive'

will raise AssertionError: x is not positive, but not if x is >= 0

x = 1
assert (x>=0), 'x is not positive'

nothing will happen
-
Handling exceptions

try: 
    a = 5 / 0
except ZeroDivisionError: 
    print('an error happened')

# running it will result in printing 'an error happened'

try:
    a = 5 / 0
except Exception as e:
    print(e)
# running will result in printing 'division by zero'

Best practice to use the exception you believe will happen.

You can try multiple operations in a try block.

try:
    a= 5 / 1 
    b = a + '10'
except ZeroDivisionError as e:
    print(e)
except TypeError as e:
    print(e)

# running will print 'unsupported operand type(s) for +: 'int' and 'str''
else: # will happen if no error is raised
    print('everything is fine')
finally: # will happen no matter what
    print('cleaning up') # usually used for cleanup
-
Defining your own exceptions:
class ValueTooHighError(Exception):
    pass
# the above is already a valid defined error

def test_value(x):
    if x > 100:
        raise ValueTooHighError('value is too high')

test_value(200)
ValueTooHighError: value is too high

try:
    test_value(200)
except ValueTooHighError as e:
    print(e)

# prints 'value is too high'

Generally worth keeping them small

class ValueTooSmallError(Exception):
    def __init__(self, message, value):
        self.message = message
        self.value = value

def test_value(x):
    if x > 100:
        raise ValueTooHighError('value is too high')
     if x < 5:
        raise ValueTooSmallError('value is too small', x)
try:
	test_value(1)
except ValueTooSmallError as e:
	print(e)
# prints 'value is too small 1'


----------------------------------
LOGGING
Python has a solid builtin logging in stdlib

import logging
five different log levels, from lowest to highest: 
logging.debug
logging.info
logging.warning
logging.error
logging.critical

default warning or above is printed


logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - (%levelname)s - %(message)s'),
    datefmt = '%m/%d/%Y %H:%M:%s')
# would show stuff of debug or higher

Best practice is not to use root logger, but instead create your own, example:

logger = logging.getLogger(__name__)  # creates a logger with the name of the module


will let you import helper

logger = logging.getLogger(__name__)
logging.propagate = False # means it won't automatically override base logger


# full creation example

logger = logging.getLogger(__name__)
#create handlers
stream_h = logging.StreamHAndler()
file_h = logging.FileHandler('file.log')
# set level
stream_h.set_level(logging.warning)
file_h.set_level(logging.error)
# set format
formatter = logging.Formatter('%(name)s - (%levelname)s - %(message)s')
stream_h.setFormatter(formatter)
file_h.setFormatter(formatter)
# set handlers
logger.addHandler(stream_h)
logger.addHandler(file_h)
# customize logger level names
logger.warning('this is a warning')
logger.error('this is an error')

You can create a file in the folder as logging.conf and define the loggers, handlers and formatters in that.
Example:
-
[handlers]
keys=consoleHandler

[formatters]
keys=simpleFormatter

[logger_root]
level=DEBUG
handlers=consoleHanlder

[logger_simpleExample]
level=DEBUG
handlers=consoleHandler
qualname=simpleExample
propagate=0

[handler_consoleHandler]
class=StreamHandler
level=DEBUG
formatter=simpleFormatter
args=(sys.stdout,)

[formatter_simpleFormatter]
format=%(asctime)s - %(name)s - %(levelname)s - %(message)s
-
you could then 
import logging
import logging.config

logging.config.fileConfig('logging.conf')
logger = logging.getLogger('simpleExample')
logger.debu('this is a debug message')

which would output 2019-06-15 17:02:47, 666 - simpleExample - DEBUG - this is a debug message

dictconfig is also an option
logging.config.dictConfig() # lets you set it as a dict

Capturing stack traces in log:

import logging

try:
    a = [1,2,3]
    val = a[4]
except IndexError as e:
    logging.error(e, exc_info=True) # exc_info=True captures whole stack trace
OR
import traceback

try:
    a = [1,2,3]
    val = a[4]
except IndexError as e:
    logging.error(e"The error is %s", traceback.format_exc())
does same thing

Rotating filehandlers: Sometimes you want to make sure the files are small for logs so you can keep track of the most recent events.

from logging.handlers import RotatingFileHandler
ex: 
handler = RotatingFileHandler('app.log', maxBytes=2000, backupCount = 5)
logger.addHandler(handler)

# this will create a new log every maxBytes, will overwrite once runs out of backupCounts

from logging.handlers import TimedRotatingFileHandler

# s, m, h, d, midnight, w0 as monday, w1 as tuesday, etc
handler = TimedRotatingFileHandler('timed_test.log', when='m', interval=1 backupCount = 5)
# will rotate at every interval whens

python-json-logger is a thing on github which will let you log in json format

--------------------------

RECURSION
A recursive function is a function defined in terms of itself via self-referential expressions.
In practical terms, this means it calls itself in its own definition.
A recursive function will have two parts: base case and recursive case.
The base case is the point where things are simple enough to solve as a single operation.
The recursive case is everything else, where we're breaking things down a step into smaller versions of the same problem.

Example: 
n! = n * (n-1) * (n-2) * etc until * 3 * 2 * 1

so we can say that
n! = n * (n-1)!
n! = n * (n-1) * (n-2)!
etc

Thus:

def factorial(num):
    if num == 1:
        return 1
    else:
        return (num * factorial(num - 1))

It's important to remember that each has its own execution context/scope, so to maintain state during recursion you need to either:
    -Thread the state through each recursive call so that the current stte is part of the current call's execution context.
    -Keep the state in global scope.

You can have multiple base cases:

def fibonacci_recursive(n):
    print("Calculating F", "(", n, ")", sep="", end=", ")

    # Base case
    if n == 0:
        return 0
    elif n == 1:
        return 1

    # Recursive case
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

You could improve on this with a decorator(!!!)
-
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_recursive(n):
    print("Calculating F", "(", n, ")", sep="", end=", ")

    # Base case
    if n == 0:
        return 0
    elif n == 1:
        return 1

    # Recursive case
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
-
lru_cache caches things, but note that it caches them as a dict, so the positional and kwargs must be hashable.

Note that Python doesn't eliminate tail calls, so if you have more stack frames than the call stack depth, you can get a (say the word, bart) STACK OVERFLOW.

This is relevant if you have a program that does deeeep recursion.
-----------------------------------------
DECORATORS

Decorators use the @decorator syntactic sugar and basically let you apply a function to another function as a wrapper, in situations where you want to decorate a bunch of functions with the same functionality.

This is useful in classes because there's things like @classmethod, @staticmethod, and @property.

@classmethod  # denotes it affects the class as a whole, not just the instance
@staticmethod  # same-ish
@property  # to customize getters and setters for class attributes

Fancy example:
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """Get value of radius"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Set radius, raise error if negative"""
        if value >= 0:
            self._radius = value
        else:
            raise ValueError("Radius must be positive")

    @property
    def area(self):
        """Calculate area inside circle"""
        return self.pi() * self.radius**2

    def cylinder_volume(self, height):
        """Calculate volume of cylinder with circle as base"""
        return self.area * height

    @classmethod
    def unit_circle(cls):
        """Factory method creating a circle with radius 1"""
        return cls(1)

    @staticmethod
    def pi():
        """Value of Ï€, could use math.pi instead though"""
        return 3.1415926535

-----------

Generator expression note: because they don't calc until called, you save a TON of memory.

-----------
JSON

json is short for
J ava
S cript
O bject
N otation
It's a lightweight data format used for data exchange, heavily used in web apps. 
Like, EXTREMELY used. It's basically the closest to agnostic data formatting we see.

-
example.json
{
    "firstName: "Jane",
    "lastName": "Doe",
    "hobbies": ["running", "swimming", "singing"],
    "age": 28
    "hasChildren": true,
    "children": [
        {
            "firstName": "Alex",
            "age": 5
        },
        {
            "firstName": "Bob",
            "age": 7
        }
    ]

}
-
Note that it looks very much like a dictionary. JSON supports primitive types (strings, numbers, boolean) as well as nested arrays and objects. Simple Python objects are translated to JSON according to the following conversion:

PYTON    JSON
dict    object
list    array
tuple    array
str    string
int    number
long    number
float    number
True    true
False    false
None    null
-
SERIALIZATION / ENCODING
import json

person = {"name": "John", "age": 30, "city": "New York", "hasChildren": False, "titles": ["engineer, programmer"]}
                                   #tuple that lets you set separators, but don't use it
personJSON = json.dumps(person,  # argument
    indent=4, # sets indent, 4 is good
     separators=(': ', '= ') # tuple that lets you set separators, but don't, that defeats point of json
     sort_keys=True  # lets you sort by keys
     )
# to dump into file
with open('person.json', 'w') as file:
    json.dump(person, file, indent=4)

# to convert BACK, aka DESERIALIZATION / decoding

person = json.loads(personJSON) # produces the original person
# from file
with open('person.json', 'r') as file:
person = json.load(person.json)

# if custom class

class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age
user = User('Max', 27)

userJSON = json.dumps(user)  # will not work, raises TypeError: Object of type User is not JSON serializable

# quick custom encoder func
def encode_user(object):
    if isinstance(object, User):
        return {'name': object.name, 'age': object.age, object.__class__.name__: True}
    else:
        raise TypeError('Object of type User is not JSON serializable')

userJSON = json.dumps(user, default=encode_user) # use the custom function here

# or custom class of encoder
from json import JSONEncoder
class UserEnconder(JSONEncoder):
    def default(self, o):
        if isinstance(o, User):
            return {'name': object.name, 'age': object.age, object.__class__.name__: True}
        return JSONEncoder.default(self, o)

userJSON = json.dumps(user, cls=UserEncoder)
# using the class directly
userJSON = UserEncoder().encod(user)

# YOu also need to custom decode classes 

def decode_user(o):
    if User.__name__ in dct:
        return User(name=dct['name'], age=dct['age'])
    return dct

user = json.loads(userJSON, object_hook=decode_user)
