Intermediate Python Notes
----------------------
List can contain multiple data types, duplicate elements.
list.insert(index, value) lets you insert items into list at index
list.remove(value) lets you kill them (valueerror if not in list)
list.clear() empties list
sorted(list) returns a sorted copy of list
mylist = [0] * 5 will make [0,0,0,0,0]
slice syntax: [start index : stop index : step]
mylist = [1,2,3,4,5,6,7,8,9,10]
mylist[1:5] = [2,3,4,5]

copy_mylist = mylist
copy_mylist.append(11)
mylist will now have 11 at the end
because both list variabless refer to the same list in the memory
copy_mylist = mylist.copy() or list(mylist) or mylist[:] all make copies that you can modify
-----------------------
tuples: immutable data type, is created by parentheses with common
mytuple = ("Max", 28, "Boston")
technically parentheses optional
mytuple = "Max", 28, "Boston" is valid
mytuple = "Max" is a string
so is mytuple = ("Max")
but mytuple = "Max", is valid
tuple(item) makes a tuple out of iterator
access them with index (mytuple[1] will get 28)
tuple.count(value) counts the number of value in tuple
tuple.index(value) returns the first index of value in tuple, will return ValueError if not in tuple
list(tuple) makes list, tuple(list) makes tuple

my_tuple = (0, 1, 2, 3, 4)
i1, *i2, i3 = my_tuple
i1 == 0
i2 == 1,2,3
i3 == 4
---------------
dicts: unordered, mutable, key:value
to merge two dicts,
my_dict = {"name",:"Max", "age":28, "email":"max@xyz.com"}
my_dict_2 = dict(name="Mary", age=27, city = "Boston")
my_dict.update(my_dict_2)

my_dict == {'name': 'Mary', 'age': 27, 'email': 'max@xyz.com', 'city': 'Boston'}

can't make mutable things keys
-------------
set: unordered, mutable, no dupes
myset = {1,2,3,1,2}
myset == {1,2,3}
myset = set("Hello")
myset == {'o', 'l', 'e', 'H'}
myset = {}
type(myset) == dict
myset = set()
type(myset) == set
myset.add(value) adds value to set
myset.discard(value) takes it out and ignores if not found
myset.pop() returns an arbitrary element while popping it out
you can iterate over it with a for loop 

unions and intersection of sets
odds = {1,3,5,7,9}
evens = {0,2,4,6,8}
primes = {2,3,5,7}

u = odds.union(evens) 
u == {0,1,2,3,4,5,6,7,8,9}
i = odds.intersection(evens)
i == set()
op = odds.intersection(primes)
op == {3,5,7}
ip = primes.intersection(evens)
ip == {2}

diff = primes.difference(odds)
diff == {2}
diff = odds.difference(primes)
diff == {1,9}
sym_diff = odds.symmetric_difference(primes)
sym_diff == {1,2}
sym_diff = primes.symmetric_difference(odds)
sym_dif == {1,2}

odds.update(primes)
odds == {1,2,3,5,7,9}
odds.intersection_update(evens)  # keeps only the stuff in both sets
odds == {2]}

odds = {1,3,5,7,9}
odds.difference_update(primes)  # removes elements from the other set
odds == {1}
also a symmetric difference version

set,issubset(other_set)  # returns True if all of set is in other_set
set.issuperset(other_set)  # returns True if all of other_set is in set
set.isdisjoint(other_set)  # returns True if there are no interesections, that is they have no elements in common


remember that simple assignment means the set has another name, it doesn't make a copy!
other_set = set.copy()
or
other_set = set(set)

Frozenset is immutable version of set
a = frozenset([1,2,3,4])
can't update

--------------

Strings
ordered and immutable collection data type
my_string = 'Hello World'
my_string.startswith('H') == True
my_string.startswith('Hello') == True
my_string.startswith('W') == False
my_string.find('l') == 2
my_string.count('o') == 2, my_string.count('p') == 0
new_string = my_string.replace('World', 'Universe')
my_string == 'Hello World'
new_string == 'Hello Universe'
var = 3.12345
my_string = "the variable is {}".format(variable)
my_string == "the variable is 3.12345"

---------------

The Collections modules implements special container data types: 
# Counter, namedtuple, OrderedDict, defaultdict, deque
-
from collections import Counter
A container that stores the elements as dictionary keys and their counts as dictionary values.
a = "aaaabbbccc"
my_counter = Counter(a)
my_counter == Counter({'a':4, 'b':3, 'c':3})
Has methods like .most_common() <- list with tuples of most common elements and count
-
from collections import namedtuple
Easy to create and lightweight object type similar to a struct
Point = namedtuple('Point', 'x,y') # creates a Point class with the values x and y
pt = Point(1, -4) # creates a Point at 1,-4
-
from collections import OrderedDict
it's a dict that cares about order, but less important since python 3.7
ordered_dict = OrderedDict()
ordered_dict['a'] = 1
ordered_dict['b'] = 2
ordered_dict['c'] = 3
ordered_dict == {'a':1, 'b':2, 'c':3}
-
from collections import defaultdict
it's a dict that comes with a default type value for all keys with un-set values
d = defaultdict(int)
d['a'] = 1
d['b'] = 2
d == {'a':1, 'b':2}
what is d['c']? d['c'] == 0

This avoids KeyErrors from absent keys
-
from collections import deque
The deque is a Double Ended Que- it can have elements removed from both ends very efficiently
d = deque()
d.append(1) # appends
d.append(2)
d == deque([1,2])
d.appendleft(3) # appends to the left
d == deque([3,1,2])
d.pop() # pops
d == deque([3,1])
d.popleft() # pops from left
d == deque([1])
d.clear()  # wipes everything 
d == deque([])
d.extend([4,5,6]) # adds a bunch
d == deque([4,5,6])
d.extendleft([1,2,3]) # from the left
d == deque([1,2,3,4,5,6])
d.rotate(1) # moves everything over one
d == deque([6,1,2,3,4,5])
d.rotate(2) # or two
d == deque([4,5,6,1,2,3])
d.rotate(-3) # can be - for backwards
d == deque([1,2,3,4,5,6])
-------------------------
ITERTOOLS
itertools: product, permutations, combinations, accumulate, groupby, and infinite iterators
iterators are data tools that can be used by a for loop, simplest example is a list.
-
Product
from itertools import product
a = [1,2]
b = [3,4]
prod = product(a,b) # computes cartesian product of them
prod == <itertools.product object>  # all of these are iterators
list(prod) == [(1,3), (1,4), (2,3), (2,4)]  # list shows what it looks like
prod = product(a,b, repeat=2) # repeats
list(prod) == [(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4), (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4), (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4), (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]
a = [1,2]
b = [3]
prod = product(a,b, repeat=2) # smaller version so you can see what happens
list(prod) == [(1, 3, 1, 3), (1, 3, 2, 3), (2, 3, 1, 3), (2, 3, 2, 3)]
it repeats the process
-
Permutations
Gives every permutation of the things fed to it.
from itertools import permutations
a = [1,2,3]
perm = permutations(a)
list(perm) == [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1
perm = permutations(a, 2) # allows you to make length 2 for example permutations only
list(perm) = [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
-
Combinations 
Makes all possible combinations with specified length
from itertools import combinations

a = [1,2,3,4]
comb = combinations(a, 2) # length is mandatory
list(comb) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]

from itertools import combinations_with_replacement # lets replacement happen so items can hit themselves
comb_wr = combinations_with_replacement(a,2)
list(comb_wr) == [(1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)]  
-
Accumulate
Allows accumulating sums 
from itertools import accumulate
a = [1,2,3,4]
>>> a
[1, 2, 3, 4]
>>> acc = accumulate(a)
>>> print(a)
[1, 2, 3, 4]
>>> print(acc)
<itertools.accumulate object at 0x10d1817c8>  # still an iterator!
>>> print(list(acc))
[1, 3, 6, 10]        # adds the thing before each item, so: nothing in, add 1 = 1. Running total is 1, add 2 = 3, running total is 3, add 3 = 6, running total is 6, add 4=10

Can also be made to do non-additions with science!
import operator
from itertools import accumulate
a = [1,2,3,4]
acc = accumulate(a, func=operator.mul)
list(acc) == [1,2,6,24] # 1 stays, 1*2 = 2, 2*3 = 6, 6 * 4 = 24
acc = accumulate(a, func=max) # checks max
list(acc) == [1,2,3,4] # 1 > null, 2>1, 3>2, 4>3
a = [1,2,5,3,4]
acc = accumulate(a, func=max)
list(acc) == [1,2,5,5,5] # 1 > null, 2>1, 5>2, 5>3, 5>4
-

Group
Lets you map things by a function
from itertools import groupby

def smaller_than_3(i):
    return x < 3

a = [1,2,3,4]
group_obj = groupby(a, key=smaller_than_3)
print(group_obj)
<itertools.groupby object at ...>

for key, value in group_obj:
    print(key, list(value))

True [1,2]
False [3,4]

It can also take lambda functions!  

-

infinite iterators:
from itertools import count, cycle, repeat
for i in count(10):
    print(i)
# starts at 10 and goes forever

a = [1,2,3]
for i in cycle(a):
    print(i)
# prints 1,2,3 infinitely

for i in repeat(1): # can take a second arg that limits
    print(i)
# print 1 infinitely


------------

Lambdas
One line anonymous (defined without a name) function in the form:

lambda arguments: expression
# creates a function with some arguments and returns the expression

add10 = lambda x: x+10
add10(5) == 15

only real difference between this and
def add10_func(x):
    return x + 10
is that the lambda is shorter and only in one line

They can have multiple arguments
mult = lambda x,y: x*y
mult(2,3) == 6

Lambdas are very useful for keys in other functions, eg:
sorted(thing, key = lambda x: x[1]) to sort by the second element in each part of thing
